<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lightview:Sites</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <script src="https://cdn.tiny.cloud/1/y2ts772rioh7s7bmlcosnef03zs6kpedu5ovw1sdfzslurej/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script>
    <script src="https://unpkg.com/@isomorphic-git/lightning-fs"></script>
    <script src="https://unpkg.com/isomorphic-git"></script>
    <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script>
    <script type="module">
        const fs = new LightningFS('my-app');
        const files = await git.listFiles({ fs, dir: '/' });
        console.log(files);
        window.fs = fs.promises;
    </script>
    <script>
        var server = new Peer("anywhichway1");
        // on open will be launch when you successfully connect to PeerServer
        server.on('open', (id) => {
            console.log(id);
        });
        server.on("connection",(conn) => {
            conn.on('data', async (data) => {
                console.log('Received', data);
                let content = await fs.readFile("/test.html",{encoding:"utf8"});
                const client = server.connect(conn.peer);
                client.on("open",() => {
                    content += `<p>${new Date().toISOString()}</p>`
                    client.send(content);
                });
            });
            //const client = server.connect(conn.peer);
        })
    </script>
    <script src="../lightview.js?as=x-body"></script>
</head>
<body style="display:flex;flex-direction:row;min-height:98vh;margin: 10px">
<div style="width:200px;min-height:100%;border:1px solid;padding-left:10px;padding-bottom:10px">
    <div style="width:100%;"><label for="hamburger" style="float:left" l-on:click="${onTabClick}">hamburger</label><br></br>Files</div>
    <div id="files"></div>
</div>
<div id="content" style="flex:auto;min-height:100%;border:1px solid;padding:10px">
    <div style="display:flex;flex-direction:column;min-height:100%">
        <div id="tabs" style="flex-grow:0;width:100%;border:1px;padding-bottom:5px;display:none">
            <label for="markdown" l-on:click="${onTabClick}">Markdown</label>
            <label for="html" l-on:click="${onTabClick}">HTML</label>
            <label for="css" l-on:click="${onTabClick}">Style</label>
            <label for="script" l-on:click="${onTabClick}">Script</label>
            <label for="head" l-on:click="${onTabClick}">Head</label>
            <label for="preview" l-on:click="${onTabClick}">Preview</label>
        </div>
        <textarea id="markdown" style="flex-grow:1;padding-right:2px;;display:none">${bodyMarkdown}</textarea>
        <textarea id="html" style="flex-grow:1;padding-right:2px;display:none">${bodyHTML}</textarea>
        <textarea id="css" style="flex-grow:1;display:none">${cssText}</textarea>
        <textarea id="script" style="flex-grow:1;display:none">${scriptText}</textarea>
        <textarea id="head" style="flex-grow:1;display:none">${headText}</textarea>
        <div id="preview" style="flex-grow:1;display:none"></div>
        <div id="hamburger"  style="flex-grow:1;display:none">options</div>
        <div id="wysiwyg" style="flex-grow:1;width:100%;border:1px solid">
        </div>
    </div>
</div>
<style id="style"></style>
<script type="lightview/module">
    const turndownService = new TurndownService({headingStyle:"atx",codeBlockStyle:"fenced",emDelimiter:"*"}),
        fs = new LightningFS('my-app').promises;
    turndownService.keep(() => true);

    const {html,css,script} = await import("../types.js");
    self.variables({
        onTabClick:"function"
    });
    self.variables({
        bodyMarkdown:html,
        bodyHTML:html,
        cssText:css,
        scriptText:script,
        headHTML:html
    },{reactive});

    let fragment;
    try {
        const fullHTML = await fs.readFile("/test.html",{encoding:"utf8"}),
          parser = new DOMParser();
        fragment = parser.parseFromString(fullHTML||"","text/html");
    } catch(e) {

    };

    const body_el = fragment?.body,
        style_el = fragment?.querySelector("style"),
        script_el = fragment?.querySelector("script");
    if(style_el) style_el.remove();
    if(script_el) script_el.remove();

    bodyHTML = body_el?.innerHTML || "";
    bodyMarkdown = "";
    cssText = style_el?.innerHTML || "";
    scriptText = script_el?.innerHTML || "",
    headHTML = fragment?.head.innerHTML || "";

    const tabs = [...self.querySelectorAll("label[for]")]
        .map((label) => {
            const id = label.getAttribute("for");
            return [id,self.getElementById(id),label];
        });

    onTabClick = (event) => {
        const targetid = event.target.getAttribute("for");
        tabs.forEach(([id,el,label]) => {
            if(id===targetid) {
                el.style.display = "unset";
                label.style.borderBottom = "solid";
            } else {
                el.style.display = "none";
                label.style.borderBottom = "none";
            }
        });
        if(targetid==="preview") doPreview();
    };

    const doPreview = () => {
        const template = document.createElement("template");
        template.innerHTML = "<style>" + cssText + "</style>" + htmlEl.value + '<script type="lightview/module">' + scriptText + "<" + "/script>";
        const component = window.customElements.get("x-preview");
        if(component) { component.setTemplateNode(template); }
        else { Lightview.createComponent("x-preview",template); }
        previewEl.innerHTML = "<x-preview></x-preview>";
        fs.writeFile("/test.html",template.innerHTML,{encoding:"utf8"},()=>{});
    };

    const wysywigEl = self.getElementById("wysiwyg"),
        markdownEl = self.getElementById("markdown"),
        htmlEl = self.getElementById("html"),
        tabsEl = self.getElementById("tabs"),
        styleEl = self.getElementById("style"),
        previewEl = self.getElementById("preview");

    let prevtext; // prevents indirect recursion
    observe(() => {
        const text = turndownService.turndown(bodyHTML).trim();
        if(text && text!==prevtext) {
            bodyMarkdown = markdownEl.innerHTML = prevtext = text;
        }
    });

    let prevhtml; // prevents indirect recursion
    observe(() => {
        const html = marked.parse(bodyMarkdown).trim();
        if(html && html!==prevhtml) {
            bodyHTML =  htmlEl.innerText  = prevhtml = html;
        }
    });

    observe(() => {
        const dummy = cssText;
        if(tinymce.activeEditor) {
            tinymce.activeEditor.destroy();
            initMCE();
        }
    });

    let advEdit = false;
    const toggleAdvEdit = () => {
        advEdit = !advEdit;
        if(advEdit) {
            tabsEl.style.display = "unset";
        } else {
            tabsEl.style.display = "none";
        }
        tabs.forEach(([_,el,label]) => {
            if(advEdit && el===markdownEl) {
                el.style.display = "unset";
                label.style.borderBottom = "solid";
                return;
            }
            el.style.display = "none";
            label.style.borderBottom = "none";
        });
        initMCE();
    };

    const initMCE = () => {
        tinymce.init({
            target: wysywigEl,
            content_style: cssText,
            setup: (editor) => {
                editor.ui.registry.addButton('advancedEdit', {
                  text: 'AdvEdit',
                  onAction: () => {
                    editor.destroy();
                    toggleAdvEdit();
                  }
                });
                editor.on("init",() => {
                    observe(()=> {
                        const html = editor.getContent();
                        if(html !== bodyHTML) {
                            editor.setContent(bodyHTML);
                        }
                    });
                });
                ["input","FormatApply","FormatRemove"]
                    .forEach((event) => {
                        editor.on(event,() => {
                            const html = editor.getContent();
                            if(!bodyHTML || (bodyHTML !== html)) {
                                bodyHTML = htmlEl.innerText =  html;
                            }
                        });
                    });
            },
            plugins: "a11ychecker advcode casechange export formatpainter image editimage linkchecker autolink lists checklist media mediaembed pageembed powerpaste searchreplace table advtable tableofcontents tinycomments tinymcespellchecker",
            toolbar: "undo redo | addcomment showcomments | h1 h2 h3 h4 formatselect casechange bullist numlist checklist | advancedEdit",
            toolbar_mode: "floating",
            tinycomments_mode: "embedded",
            tinycomments_author: "Author name",
            removed_menuitems: 'fontsizes, fontformats, forecolor, backcolor, lineheight, inline, inserttable code undo redo',
            style_formats: [
              { title: 'Headings', items: [
                    { title: 'Heading 1', format: 'h1' },
                    { title: 'Heading 2', format: 'h2' },
                    { title: 'Heading 3', format: 'h3' },
                    { title: 'Heading 4', format: 'h4' },
                    { title: 'Heading 5', format: 'h5' },
                    { title: 'Heading 6', format: 'h6' }
                  ]
              }
           ],
           statusbar: false,
           menu: {
            format: {title: 'Format', items: 'bold italic underline strikethrough superscript subscript | codeformat blockformats align | removeformat'}
           }
        });
    };

    self.addEventListener("connected",() => {
        initMCE();
    });

// format: remove fonts, line height, text color, background color formats.inline, formats.block.div and formats.blocks.pre, block.pre
// view: remove source code
</script>
</body>
</html>