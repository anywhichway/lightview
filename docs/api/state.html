<!-- SEO-friendly SPA Shim -->
<script src="/lightview-router.js?base=/index.html"></script>

<div class="docs-layout">
    <aside class="docs-sidebar" src="./nav.html" data-preserve-scroll="docs-nav"></aside>

    <main class="docs-content">
        <h1>State (Store)</h1>
        <p>
            State provides deep reactivity for objects and arrays. Unlike signals which only track reassignment,
            state tracks nested property changes automatically.
        </p>

        <h2 id="shortcomings">The Shortcomings of Signals</h2>
        <pre><code>// Signals only react to reassignment
const user = signal({ name: 'Alice', age: 25 });

user.value.age = 26;           // ‚ùå Won't trigger updates!
user.value = { ...user.value, age: 26 };  // ‚úÖ Works, but verbose

// Arrays have the same issue
const items = signal([1, 2, 3]);
items.value.push(4);           // ‚ùå Won't trigger updates!
items.value = [...items.value, 4];  // ‚úÖ Works, but tedious</code></pre>

        <h2 id="state-to-the-rescue">State to the Rescue</h2>
        <pre><code>const { state } = LightviewX;

// Deep reactivity - mutations work!
const user = state({ name: 'Alice', age: 25 });

user.age = 26;                 // ‚úÖ Triggers updates!
user.name = 'Bob';             // ‚úÖ Triggers updates!

// Arrays just work
const items = state([1, 2, 3]);
items.push(4);                 // ‚úÖ Triggers updates!
items[0] = 10;                 // ‚úÖ Triggers updates!
items.sort();                  // ‚úÖ Triggers updates!</code></pre>

        <h2 id="nested-objects">Nested Objects</h2>
        <p>State tracks changes at any depth:</p>
        <pre><code>const app = state({
    user: {
        profile: {
            name: 'Alice',
            settings: {
                theme: 'dark',
                notifications: true
            }
        }
    },
    items: []
});

// All of these trigger updates:
app.user.profile.name = 'Bob';
app.user.profile.settings.theme = 'light';
app.items.push({ id: 1, text: 'Hello' });</code></pre>

        <h2 id="in-the-ui">In the UI</h2>

        <div class="code-example">
            <div class="code-example-preview" id="state-demo"></div>
            <div class="code-example-code">
                <pre><code>const todos = state([
    { text: 'Learn Lightview', done: true },
    { text: 'Build app', done: false }
]);

div(
    ul(() => todos.map((todo, i) => 
        li(
            input({ 
                type: 'checkbox', 
                checked: todo.done,
                onchange: () => todos[i].done = !todos[i].done
            }),
            span(todo.text)
        )
    )),
    button({ onclick: () => todos.push({ text: 'New', done: false }) }, 'Add')
)</code></pre>
            </div>
        </div>

        <h2 id="array-methods">Array Methods</h2>
        <p>All mutating array methods are reactive:</p>
        <pre><code>const items = state([1, 2, 3]);

items.push(4);         // Add to end
items.pop();           // Remove from end
items.shift();         // Remove from start
items.unshift(0);      // Add to start
items.splice(1, 1);    // Remove at index
items.sort();          // Sort in place
items.reverse();       // Reverse in place
items.fill(0);         // Fill with value</code></pre>

        <h2 id="named-state">Named State</h2>
        <p>
            Like signals, you can name state objects for global access. This is especially useful for
            shared application state:
        </p>
        <pre><code>// Create named state
const appState = state({ 
    user: 'Guest', 
    theme: 'dark' 
}, 'app');

// Retrieve it anywhere
const globalState = state.get('app');

// Get or create
const settings = state.get('settings', { notifications: true });</code></pre>

        <h2 id="stored-state">Stored State</h2>
        <p>
            You can store named state objects in Storage objects (e.g. sessionStorage or localStorage) for persistence.
            It will be saved any time there is a change. Objects are automatically
            serialized to JSON and deserialized back to objects.
        </p>
        <pre><code>const user = state({name:'Guest', theme:'dark'}, {name:'user', storage:sessionStorage});

// Retrieve it elsewhere (even in another file)
const sameUser = state.get('user');

// Get or create with default value
// If 'user' exists, returns it. If not, creates it with default value.
const score = state.get('user', {storage:sessionStorage, defaultValue:{name:'Guest', theme:'dark'}});</code></pre>
        <p>Note: Manually updating the object in storage will not trigger updates.</p>

        <h2 id="schema-validation">Schema Validation</h2>
        <p>
            State objects can be validated and transformed using the <code>schema</code> option. This ensures data
            integrity and can automatically coerce values to the expected types.
        </p>
        <pre><code>const user = state({ name: 'Alice', age: 25 }, { schema: 'auto' });

user.age = 26;          // ‚úÖ Works (same type)
user.age = '30';        // ‚ùå Throws: Type mismatch
user.status = 'active'; // ‚ùå Throws: Cannot add new property</code></pre>

        <h3>Built-in Schema Behaviors</h3>
        <table class="api-table">
            <thead>
                <tr>
                    <th>Behavior</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>"auto"</code></td>
                    <td>Infers a fixed schema from the initial value. Prevents adding new properties and enforces strict
                        type checking.</td>
                </tr>
                <tr>
                    <td><code>"dynamic"</code></td>
                    <td>Like <code>auto</code>, but allows the state object to grow with new properties.</td>
                </tr>
                <tr>
                    <td><code>"polymorphic"</code></td>
                    <td>Allows growth and automatically <strong>coerces</strong> values to match the initial type (e.g.,
                        setting "100" to a number property saves it as the number 100).</td>
                </tr>
            </tbody>
        </table>
        <pre><code>// Polymorphic coerces types automatically
const settings = state({ volume: 50, muted: false }, { schema: 'polymorphic' });

settings.volume = '75';   // ‚úÖ Coerced to number 75
settings.muted = 'true';   // ‚úÖ Coerced to boolean true
settings.newProp = 'ok';  // ‚úÖ Allowed (dynamic growth)</code></pre>

        <h3 id="json-schema-lite">JSON Schema Lite</h3>
        <p>
            When you load <code>lightview-x.js</code>, the schema engine is upgraded to a "JSON Schema Lite" validator.
            It supports standard Draft 7 keywords while remaining incredibly lightweight.
        </p>

        <h4>Supported Keywords</h4>
        <table class="api-table">
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Keywords</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>String</strong></td>
                    <td><code>minLength</code>, <code>maxLength</code>, <code>pattern</code>,
                        <code>format: 'email'</code>
                    </td>
                </tr>
                <tr>
                    <td><strong>Number</strong></td>
                    <td><code>minimum</code>, <code>maximum</code>, <code>multipleOf</code></td>
                </tr>
                <tr>
                    <td><strong>Object</strong></td>
                    <td><code>required</code>, <code>properties</code>, <code>additionalProperties: false</code></td>
                </tr>
                <tr>
                    <td><strong>Array</strong></td>
                    <td><code>items</code>, <code>minItems</code>, <code>maxItems</code>, <code>uniqueItems</code></td>
                </tr>
                <tr>
                    <td><strong>General</strong></td>
                    <td><code>type</code>, <code>enum</code>, <code>const</code></td>
                </tr>
            </tbody>
        </table>

        <h3 id="transformations">Transformation Helpers</h3>
        <p>
            Unlike industry-standard validators (which only allow/disallow data), Lightview's engine supports
            <strong>declarative transformations</strong>. This allows you to specify how data should be "cleaned" before
            it hits the state.
        </p>
        <pre><code>const UserSchema = {
    type: "object",
    properties: {
        username: { 
            type: "string", 
            transform: "lower"  // Using a registered helper name
        },
        salary: { 
            type: "number",
            transform: (v) => Math.round(v) // Using an inline function
        }
    }
};

const user = state({ username: 'ALICE', salary: 50212.55 }, { schema: UserSchema });
// user.username is 'alice' (via "lower")
// user.salary is 50213 (via inline function)</code></pre>

        <p>
            When using a <strong>string</strong> for the transform (like <code>"lower"</code>), Lightview looks for a
            matching function in the global registry. This requires that the helper has been registered via JPRX
            (requires <code>lightview-cdom.js</code>) or manually in <code>Lightview.helpers</code>.
        </p>

        <div class="code-block info"
            style="border-left: 4px solid #3b82f6; padding: 1rem; background: #eff6ff; margin-bottom: 2rem;">
            <strong>üîç Naming Tip:</strong> When using string names for transforms, use the <strong>bare helper
                name</strong> (e.g., <code>"lower"</code>, <code>"round"</code>). You do <strong>not</strong> need a
            leading <code>$</code>.
        </div>

        <h4>Loading Helpers</h4>
        <p>
            When using the <code>transform</code> keyword, Lightview searches for the named function in the following
            order:
        </p>
        <ol style="margin-bottom: 2rem;">
            <li><strong>JPRX Helpers</strong>: Any helper registered via <code>registerHelper</code> (requires
                <code>lightview-cdom.js</code>).
            </li>
            <li><strong>Public API</strong>: Functions attached to <code>Lightview.helpers</code>.</li>
            <li><strong>Inline</strong>: You can also pass a function directly to the <code>transform</code> property.
            </li>
        </ol>

        <div class="code-block info"
            style="border-left: 4px solid #3b82f6; padding: 1rem; background: #eff6ff; margin-bottom: 2rem;">
            <strong>üí° Note:</strong> To use JPRX helpers (like <code>math</code>, <code>string</code>, or
            <code>array</code> helpers) for state transformations, you must ensure <code>lightview-cdom.js</code> is
            loaded before your state is initialized.
        </div>

        <h3 id="lite-vs-full">Lite vs. Full Validators</h3>
        <p>
            Why use our "Lite" engine instead of a full validator like <strong>Ajv</strong>?
        </p>
        <table class="api-table">
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Lightview Lite</th>
                    <th>Full (Ajv, etc.)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Size</strong></td>
                    <td>~2KB (built-in)</td>
                    <td>~40KB+ (external)</td>
                </tr>
                <tr>
                    <td><strong>Transformation</strong></td>
                    <td>‚úÖ First-class support</td>
                    <td>‚ùå Not supported (Validators only)</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>üöÄ Optimized for UI cycles</td>
                    <td>Heavy overhead for simple checks</td>
                </tr>
                <tr>
                    <td><strong>Spec Compliance</strong></td>
                    <td>Basic Draft 7 (No <code>$ref</code>)</td>
                    <td>100% Full Specification</td>
                </tr>
            </tbody>
        </table>

        <h4 id="full-validator">Using a Full Validator</h4>
        <p>
            If you have complex enterprise schemas that require full specification compliance, you can swap out the
            Lightview engine for any industry-standard validator:
        </p>
        <div class="code-block warning"
            style="border-left: 4px solid #f59e0b; padding: 1rem; background: #fffbeb; margin-bottom: 2rem;">
            <strong>‚ö†Ô∏è Warning:</strong> If you swap the validator, you will lose support for the declarative
            <code>transform</code> keyword in your schemas unless your external validator also supports it.
        </div>
        <pre><code>import Ajv from "ajv";
const ajv = new Ajv();

// Swap the validation hook
Lightview.internals.hooks.validate = (value, schema) => {
    const valid = ajv.validate(schema, value);
    if (!valid) throw new Error(ajv.errorsText());
    return true;
};</code></pre>

        <h2 id="signal-vs-state">Signal vs State</h2>
        <table class="api-table">
            <thead>
                <tr>
                    <th>Use Signal</th>
                    <th>Use State</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Primitives (numbers, strings, bools)</td>
                    <td>Objects with nested properties</td>
                </tr>
                <tr>
                    <td>Simple objects (replace whole thing)</td>
                    <td>Objects you'll mutate in place</td>
                </tr>
                <tr>
                    <td>Arrays you'll replace</td>
                    <td>Arrays you'll push/pop/splice</td>
                </tr>
                <tr>
                    <td>Slightly better performance</td>
                    <td>More convenient API</td>
                </tr>
            </tbody>
        </table>

        <h2>Pro Tip</h2>
        <p>
            You can mix both! Use signals for simple values and state for complex structures:
        </p>
        <pre><code>const isLoading = signal(false);      // Simple boolean ‚Üí signal
const error = signal(null);           // Simple value ‚Üí signal
const items = state([]);              // Array to mutate ‚Üí state (from LightviewX)
const formData = state({              // Object to mutate ‚Üí state (from LightviewX)
    name: '',
    email: '',
    message: ''
});</code></pre>
    </main>
</div>

<script>
    (function () {
        const { tags } = Lightview;
        const { state } = LightviewX;
        const { div, ul, li, input, span, button } = tags;

        const todos = state([
            { text: 'Learn Lightview', done: true },
            { text: 'Build something', done: false }
        ]);

        const demo = div({ style: 'padding: 0.5rem;' },
            ul({ style: 'list-style: none; padding: 0; margin: 0 0 1rem;' },
                () => todos.map((todo, i) =>
                    li({ style: 'display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0;' },
                        input({
                            type: 'checkbox',
                            checked: todo.done,
                            onchange: () => todos[i].done = !todos[i].done,
                            style: 'cursor: pointer;'
                        }),
                        span({
                            style: () => `${todo.done ? 'text-decoration: line-through; opacity: 0.6;' : ''}`
                        }, todo.text)
                    )
                )
            ),
            button({
                onclick: () => todos.push({ text: `Task ${todos.length + 1}`, done: false }),
                style: 'padding: 0.5rem 1rem; cursor: pointer; background: var(--site-primary); color: white; border: none; border-radius: 6px;'
            }, '+ Add Task')
        );

        const container = document.getElementById('state-demo');
        if (container) container.appendChild(demo.domEl);
    })();
</script>